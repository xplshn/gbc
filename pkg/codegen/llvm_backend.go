package codegen

import (
	"bytes"
	"fmt"
	"math"
	"os"
	"os/exec"
	"sort"
	"strconv"
	"strings"

	"github.com/xplshn/gbc/pkg/config"
	"github.com/xplshn/gbc/pkg/ir"
)

type llvmBackend struct {
	out       *strings.Builder
	prog      *ir.Program
	cfg       *config.Config
	wordType  string
	tempTypes map[string]string
	funcSigs  map[string]string
	currentFn *ir.Func
}

func NewLLVMBackend() Backend { return &llvmBackend{} }

func (b *llvmBackend) Generate(prog *ir.Program, cfg *config.Config) (*bytes.Buffer, error) {
	var llvmIRBuilder strings.Builder
	b.out = &llvmIRBuilder
	b.prog = prog
	b.cfg = cfg
	b.wordType = fmt.Sprintf("i%d", cfg.WordSize*8)
	b.tempTypes = make(map[string]string)
	b.funcSigs = make(map[string]string)

	b.gen()

	llvmIR := llvmIRBuilder.String()
	asm, err := b.compileLLVMIR(llvmIR)
	if err != nil { return nil, err }
	return bytes.NewBufferString(asm), nil
}

func (b *llvmBackend) compileLLVMIR(llvmIR string) (string, error) {
	llFile, err := os.CreateTemp("", "gbc-main-*.ll")
	if err != nil { return "", fmt.Errorf("failed to create temp file for LLVM IR: %w", err) }
	defer os.Remove(llFile.Name())
	if _, err := llFile.WriteString(llvmIR); err != nil {
		return "", fmt.Errorf("failed to write to temp file for LLVM IR: %w", err)
	}
	llFile.Close()

	asmFile, err := os.CreateTemp("", "gbc-main-*.s")
	if err != nil { return "", fmt.Errorf("failed to create temp file for assembly: %w", err) }
	asmFile.Close()
	defer os.Remove(asmFile.Name())

	cmd := exec.Command("llc", "-O3", "-o", asmFile.Name(), llFile.Name())
	if output, err := cmd.CombinedOutput(); err != nil {
		return "", fmt.Errorf("llc command failed: %w\n--- LLVM IR ---\n%s\n--- Output ---\n%s", err, llvmIR, string(output))
	}

	asmBytes, err := os.ReadFile(asmFile.Name())
	if err != nil { return "", fmt.Errorf("failed to read temporary assembly file: %w", err) }
	return string(asmBytes), nil
}

func (b *llvmBackend) gen() {
	fmt.Fprintf(b.out, "; Generated by gbc\n")
	fmt.Fprintf(b.out, "target triple = \"%s\"\n\n", b.cfg.BackendTarget)

	b.genDeclarations()
	b.genStrings()
	b.genGlobals()

	for _, fn := range b.prog.Funcs {
		b.genFunc(fn)
	}
}

func (b *llvmBackend) getFuncSig(name string) (retType string) { return b.wordType }

func (b *llvmBackend) genDeclarations() {
	knownExternals := make(map[string]bool)

	b.out.WriteString("declare void @llvm.memcpy.p0i8.p0i8.i64(i8*, i8*, i64, i1)\n")

	if len(b.prog.ExtrnVars) > 0 {
		b.out.WriteString("; --- External Variables ---\n")
		for name := range b.prog.ExtrnVars {
			if knownExternals[name] { continue }
			ptrType := "i8*"
			fmt.Fprintf(b.out, "@%s = external global %s\n", name, ptrType)
			b.tempTypes["@"+name] = ptrType + "*"
			knownExternals[name] = true
		}
		b.out.WriteString("\n")
	}

	potentialFuncs := make(map[string]bool)
	for _, name := range b.prog.ExtrnFuncs {
		potentialFuncs[name] = true
	}
	for _, fn := range b.prog.Funcs {
		for _, block := range fn.Blocks {
			for _, instr := range block.Instructions {
				if instr.Op == ir.OpCall {
					if g, ok := instr.Args[0].(*ir.Global); ok {
						potentialFuncs[g.Name] = true
					}
				}
			}
		}
	}

	for _, fn := range b.prog.Funcs {
		delete(potentialFuncs, fn.Name)
	}

	var funcsToDeclare []string
	for name := range potentialFuncs {
		if !knownExternals[name] {
			funcsToDeclare = append(funcsToDeclare, name)
		}
	}

	if len(funcsToDeclare) > 0 {
		b.out.WriteString("; --- External Functions ---\n")
		sort.Strings(funcsToDeclare)
		for _, name := range funcsToDeclare {
			retType := b.getFuncSig(name)
			sig := fmt.Sprintf("declare %s @%s(...)\n", retType, name)
			b.out.WriteString(sig)
			b.funcSigs[name] = sig
		}
		b.out.WriteString("\n")
	}
}

func (b *llvmBackend) genStrings() {
	if len(b.prog.Strings) == 0 { return }
	b.out.WriteString("; --- String Literals ---\n")
	for s, label := range b.prog.Strings {
		strLen := len(s) + 1
		escaped := b.escapeString(s)
		typeStr := fmt.Sprintf("[%d x i8]", strLen)
		fmt.Fprintf(b.out, "@%s = private unnamed_addr constant %s c\"%s\\00\"\n", label, typeStr, escaped)
		b.tempTypes["@"+label] = typeStr + "*"
	}
	b.out.WriteString("\n")
}

func (b *llvmBackend) genGlobals() {
	if len(b.prog.Globals) == 0 { return }
	b.out.WriteString("; --- Global Variables ---\n")
	for _, g := range b.prog.Globals {
		hasInitializer := false
		totalItemCount := 0
		var firstItemType ir.Type = -1

		for _, item := range g.Items {
			if item.Count > 0 {
				totalItemCount += item.Count
			} else {
				totalItemCount++
				hasInitializer = true
			}
			if firstItemType == -1 { firstItemType = item.Typ }
		}

		var globalType string
		elemType := b.formatType(firstItemType)
		if firstItemType == -1 { elemType = b.wordType }

		if totalItemCount > 1 {
			globalType = fmt.Sprintf("[%d x %s]", totalItemCount, elemType)
		} else if totalItemCount == 1 {
			globalType = elemType
		} else {
			continue
		}

		initializer := "zeroinitializer"
		if hasInitializer {
			if strings.HasPrefix(globalType, "[") {
				var typedItems []string
				for _, item := range g.Items {
					if item.Count > 0 {
						for i := 0; i < item.Count; i++ {
							typedItems = append(typedItems, fmt.Sprintf("%s 0", elemType))
						}
					} else {
						itemTypeStr := b.formatType(item.Typ)
						valStr := b.formatGlobalInitializerValue(item.Value, itemTypeStr)
						typedItems = append(typedItems, fmt.Sprintf("%s %s", itemTypeStr, valStr))
					}
				}
				initializer = fmt.Sprintf("[ %s ]", strings.Join(typedItems, ", "))
			} else {
				initializer = b.formatGlobalInitializerValue(g.Items[0].Value, globalType)
			}
		}

		fmt.Fprintf(b.out, "@%s = global %s %s, align %d\n", g.Name, globalType, initializer, g.Align)
		b.tempTypes["@"+g.Name] = globalType + "*"
	}
	b.out.WriteString("\n")
}

func (b *llvmBackend) formatGlobalInitializerValue(v ir.Value, targetType string) string {
	switch val := v.(type) {
	case *ir.Const:
		return fmt.Sprintf("%d", val.Value)
	case *ir.FloatConst:
		if targetType == "float" { return fmt.Sprintf("0x%X", math.Float32bits(float32(val.Value))) }
		return fmt.Sprintf("0x%X", math.Float64bits(val.Value))
	case *ir.Global:
		strContent, isString := b.prog.IsStringLabel(val.Name)
		if isString {
			strType := fmt.Sprintf("[%d x i8]", len(strContent)+1)
			gep := fmt.Sprintf("getelementptr inbounds (%s, %s* @%s, i64 0, i64 0)", strType, strType, val.Name)
			if targetType != "i8*" { return fmt.Sprintf("ptrtoint (i8* %s to %s)", gep, targetType) }
			return gep
		}
		sourceType := b.getType(val)
		if !strings.HasSuffix(sourceType, "*") { sourceType += "*" }
		return fmt.Sprintf("bitcast (%s @%s to %s)", sourceType, val.Name, targetType)
	default:
		return "0"
	}
}

func (b *llvmBackend) genFunc(fn *ir.Func) {
	b.currentFn = fn
	globalTypes := make(map[string]string)
	for k, v := range b.tempTypes {
		if strings.HasPrefix(k, "@") { globalTypes[k] = v }
	}
	b.tempTypes = globalTypes

	retTypeStr := b.formatType(fn.ReturnType)
	var params []string
	for _, p := range fn.Params {
		pName := b.formatValue(p.Val)
		pType := b.formatType(p.Typ)
		if fn.Name == "main" && p.Name == "argv" { pType = "i8**" }
		params = append(params, fmt.Sprintf("%s %s", pType, pName))
		b.tempTypes[pName] = pType
	}
	paramStr := strings.Join(params, ", ")
	if fn.HasVarargs {
		if len(params) > 0 { paramStr += ", " }
		paramStr += "..."
	}

	fmt.Fprintf(b.out, "define %s @%s(%s) {\n", retTypeStr, fn.Name, paramStr)
	for i, block := range fn.Blocks {
		labelName := block.Label.Name
		if i == 0 { labelName = "entry" }
		fmt.Fprintf(b.out, "%s:\n", labelName)
		b.genBlock(block)
	}
	b.out.WriteString("}\n")
}

func (b *llvmBackend) genBlock(block *ir.BasicBlock) {
	var deferredCasts []string
	phiEndIndex := 0

	for i, instr := range block.Instructions {
		if instr.Op != ir.OpPhi {
			phiEndIndex = i
			break
		}
	}
	if phiEndIndex == 0 && len(block.Instructions) > 0 && block.Instructions[0].Op == ir.OpPhi {
		phiEndIndex = len(block.Instructions)
	}

	for _, instr := range block.Instructions[:phiEndIndex] {
		if instr.Op == ir.OpPhi {
			cast := b.genPhi(instr)
			if cast != "" { deferredCasts = append(deferredCasts, cast) }
		}
	}

	for _, cast := range deferredCasts {
		b.out.WriteString(cast)
	}

	for _, instr := range block.Instructions[phiEndIndex:] {
		b.genInstr(instr)
	}
}

func (b *llvmBackend) genInstr(instr *ir.Instruction) {
	if instr.Op == ir.OpPhi { return }

	resultName := ""
	if instr.Result != nil { resultName = b.formatValue(instr.Result) }

	b.out.WriteString("\t")

	switch instr.Op {
	case ir.OpAlloc:
		align := instr.Align
		if align == 0 { align = b.cfg.StackAlignment }
		sizeVal := b.prepareArg(instr.Args[0], b.wordType)
		fmt.Fprintf(b.out, "%s = alloca i8, %s %s, align %d\n", resultName, b.wordType, sizeVal, align)
		b.tempTypes[resultName] = "i8*"

	case ir.OpLoad:
		valType := b.formatType(instr.Typ)
		ptrType := valType + "*"
		ptrVal := b.prepareArg(instr.Args[0], ptrType)
		fmt.Fprintf(b.out, "%s = load %s, %s %s, align %d\n", resultName, valType, ptrType, ptrVal, ir.SizeOfType(instr.Typ, b.cfg.WordSize))
		b.tempTypes[resultName] = valType

	case ir.OpStore:
		valType := b.formatType(instr.Typ)
		ptrType := valType + "*"
		ptrVal := b.prepareArg(instr.Args[1], ptrType)
		valStr := b.prepareArg(instr.Args[0], valType)
		fmt.Fprintf(b.out, "store %s %s, %s %s, align %d\n", valType, valStr, ptrType, ptrVal, ir.SizeOfType(instr.Typ, b.cfg.WordSize))

	case ir.OpAdd:
		b.genAdd(instr)

	case ir.OpCast:
		targetType := b.formatType(instr.Typ)
		sourceValStr := b.prepareArg(instr.Args[0], targetType)
		if sourceValStr != resultName {
			sourceType := b.getType(instr.Args[0])
			if strings.HasSuffix(targetType, "*") {
				fmt.Fprintf(b.out, "%s = bitcast %s %s to %s\n", resultName, sourceType, sourceValStr, targetType)
			} else {
				fmt.Fprintf(b.out, "%s = add %s %s, 0\n", resultName, targetType, sourceValStr)
			}
		}
		b.tempTypes[resultName] = targetType

	case ir.OpCall:
		b.genCall(instr)

	case ir.OpJmp:
		fmt.Fprintf(b.out, "br label %%%s\n", instr.Args[0].String())

	case ir.OpJnz:
		condVal := b.prepareArg(instr.Args[0], "i1")
		fmt.Fprintf(b.out, "br i1 %s, label %%%s, label %%%s\n", condVal, instr.Args[1].String(), instr.Args[2].String())

	case ir.OpRet:
		if len(instr.Args) > 0 && instr.Args[0] != nil {
			retType := b.formatType(b.currentFn.ReturnType)
			var retVal string
			if c, ok := instr.Args[0].(*ir.Const); ok && c.Value == 0 && strings.HasSuffix(retType, "*") {
				retVal = "null"
			} else {
				retVal = b.prepareArg(instr.Args[0], retType)
			}
			fmt.Fprintf(b.out, "ret %s %s\n", retType, retVal)
		} else {
			fmt.Fprintf(b.out, "ret void\n")
		}

	case ir.OpCEq, ir.OpCNeq, ir.OpCLt, ir.OpCGt, ir.OpCLe, ir.OpCGe:
		lhsType, rhsType := b.getType(instr.Args[0]), b.getType(instr.Args[1])

		var valType string
		lhsIsPtr := strings.HasSuffix(lhsType, "*") || (lhsType == "unknown" && b.isPointerValue(instr.Args[0]))
		rhsIsPtr := strings.HasSuffix(rhsType, "*") || (rhsType == "unknown" && b.isPointerValue(instr.Args[1]))

		if lhsIsPtr || rhsIsPtr {
			valType = "i8*"
		} else if lhsType != "unknown" && lhsType != b.wordType {
			valType = lhsType
		} else if rhsType != "unknown" && rhsType != b.wordType {
			valType = rhsType
		} else {
			valType = b.wordType
		}

		isFloat := valType == "float" || valType == "double"
		var opStr, predicate string
		if isFloat {
			opStr = "fcmp"
			switch instr.Op {
			case ir.OpCEq: predicate = "oeq"
			case ir.OpCNeq: predicate = "one"
			case ir.OpCLt: predicate = "olt"
			case ir.OpCGt: predicate = "ogt"
			case ir.OpCLe: predicate = "ole"
			case ir.OpCGe: predicate = "oge"
			}
		} else {
			opStr = "icmp"
			switch instr.Op {
			case ir.OpCEq: predicate = "eq"
			case ir.OpCNeq: predicate = "ne"
			case ir.OpCLt: predicate = "slt"
			case ir.OpCGt: predicate = "sgt"
			case ir.OpCLe: predicate = "sle"
			case ir.OpCGe: predicate = "sge"
			}
		}

		lhs := b.prepareArgForComparison(instr.Args[0], valType)
		rhs := b.prepareArgForComparison(instr.Args[1], valType)

		i1Temp := b.newBackendTemp()
		fmt.Fprintf(b.out, "%s = %s %s %s %s, %s\n", i1Temp, opStr, predicate, valType, lhs, rhs)
		b.tempTypes[i1Temp] = "i1"
		fmt.Fprintf(b.out, "\t%s = zext i1 %s to %s\n", resultName, i1Temp, b.wordType)
		b.tempTypes[resultName] = b.wordType

	case ir.OpNegF:
		opStr, _ := b.formatOp(instr.Op)
		valType := b.formatType(instr.Typ)
		arg := b.prepareArg(instr.Args[0], valType)
		fmt.Fprintf(b.out, "%s = %s %s %s\n", resultName, opStr, valType, arg)
		b.tempTypes[resultName] = valType
	case ir.OpSub, ir.OpSubF, ir.OpMul, ir.OpMulF, ir.OpDiv, ir.OpDivF, ir.OpRem, ir.OpRemF, ir.OpAnd, ir.OpOr, ir.OpXor, ir.OpShl, ir.OpShr:
		opStr, _ := b.formatOp(instr.Op)
		valType := b.formatType(instr.Typ)
		lhs := b.prepareArg(instr.Args[0], valType)
		rhs := b.prepareArg(instr.Args[1], valType)
		fmt.Fprintf(b.out, "%s = %s %s %s, %s\n", resultName, opStr, valType, lhs, rhs)
		b.tempTypes[resultName] = valType

	case ir.OpBlit:
		if len(instr.Args) >= 2 {
			srcPtr := b.prepareArg(instr.Args[0], "i8*")
			dstPtr := b.prepareArg(instr.Args[1], "i8*")
			var sizeVal string
			if len(instr.Args) >= 3 {
				sizeVal = b.prepareArg(instr.Args[2], b.wordType)
			} else {
				sizeVal = fmt.Sprintf("%d", ir.SizeOfType(instr.Typ, b.cfg.WordSize))
			}
			fmt.Fprintf(b.out, "call void @llvm.memcpy.p0i8.p0i8.i64(i8* %s, i8* %s, i64 %s, i1 false)\n",
				dstPtr, srcPtr, sizeVal)
		}

	case ir.OpSWToF, ir.OpSLToF:
		valType := b.formatType(instr.Typ)
		srcType := b.wordType
		if instr.Op == ir.OpSWToF { srcType = "i32" }
		srcVal := b.prepareArg(instr.Args[0], srcType)
		fmt.Fprintf(b.out, "%s = sitofp %s %s to %s\n", resultName, srcType, srcVal, valType)
		b.tempTypes[resultName] = valType

	case ir.OpFToF:
		valType := b.formatType(instr.Typ)
		srcType := b.getType(instr.Args[0])
		srcVal := b.prepareArg(instr.Args[0], srcType)

		var castOp string
		if valType == "double" && srcType == "float" {
			castOp = "fpext"
		} else if valType == "float" && srcType == "double" {
			castOp = "fptrunc"
		} else {
			castOp = "bitcast"
		}
		fmt.Fprintf(b.out, "%s = %s %s %s to %s\n", resultName, castOp, srcType, srcVal, valType)
		b.tempTypes[resultName] = valType

	case ir.OpFToSI, ir.OpFToUI:
		valType := b.formatType(instr.Typ)
		srcType := b.getType(instr.Args[0])
		srcVal := b.prepareArg(instr.Args[0], srcType)
		castOp := "fptosi"
		if instr.Op == ir.OpFToUI { castOp = "fptoui" }
		fmt.Fprintf(b.out, "%s = %s %s %s to %s\n", resultName, castOp, srcType, srcVal, valType)
		b.tempTypes[resultName] = valType

	case ir.OpExtSB, ir.OpExtUB, ir.OpExtSH, ir.OpExtUH, ir.OpExtSW, ir.OpExtUW:
		valType := b.formatType(instr.Typ)
		var srcType, castOp string
		switch instr.Op {
		case ir.OpExtSB, ir.OpExtUB:
			srcType, castOp = "i8", "sext"
			if instr.Op == ir.OpExtUB { castOp = "zext" }
		case ir.OpExtSH, ir.OpExtUH:
			srcType, castOp = "i16", "sext"
			if instr.Op == ir.OpExtUH { castOp = "zext" }
		case ir.OpExtSW, ir.OpExtUW:
			srcType, castOp = "i32", "sext"
			if instr.Op == ir.OpExtUW { castOp = "zext" }
		}
		srcVal := b.prepareArg(instr.Args[0], srcType)
		fmt.Fprintf(b.out, "%s = %s %s %s to %s\n", resultName, castOp, srcType, srcVal, valType)
		b.tempTypes[resultName] = valType

	default:
		opStr, _ := b.formatOp(instr.Op)
		valType := b.formatType(instr.Typ)
		lhs := b.prepareArg(instr.Args[0], valType)
		rhs := b.prepareArg(instr.Args[1], valType)
		fmt.Fprintf(b.out, "%s = %s %s %s, %s\n", resultName, opStr, valType, lhs, rhs)
		b.tempTypes[resultName] = valType
	}
}

func (b *llvmBackend) genPhi(instr *ir.Instruction) string {
	resultName := b.formatValue(instr.Result)
	originalResultType := b.formatType(instr.Typ)
	phiType := originalResultType

	hasPtrInput, hasIntInput := false, false
	for i := 1; i < len(instr.Args); i += 2 {
		argType := b.getType(instr.Args[i])
		if strings.HasSuffix(argType, "*") {
			hasPtrInput = true
		} else if strings.HasPrefix(argType, "i") {
			hasIntInput = true
		}
	}

	if hasPtrInput && hasIntInput { phiType = "i8*" }

	var pairs []string
	for i := 0; i < len(instr.Args); i += 2 {
		labelName := instr.Args[i].String()
		if labelName == "start" { labelName = "entry" }
		val := b.prepareArgForPhi(instr.Args[i+1], phiType)
		pairs = append(pairs, fmt.Sprintf("[ %s, %%%s ]", val, labelName))
	}

	phiResultName := resultName
	if phiType != originalResultType { phiResultName = b.newBackendTemp() }

	fmt.Fprintf(b.out, "\t%s = phi %s %s\n", phiResultName, phiType, strings.Join(pairs, ", "))
	b.tempTypes[phiResultName] = phiType

	if phiResultName != resultName {
		b.tempTypes[resultName] = originalResultType
		return fmt.Sprintf("\t%s\n", b.formatCast(phiResultName, resultName, phiType, originalResultType))
	}
	return ""
}

func (b *llvmBackend) prepareArgForPhi(v ir.Value, targetType string) string {
	valStr := b.formatValue(v)
	currentType := b.getType(v)

	if currentType == targetType || currentType == "unknown" { return valStr }

	if c, isConst := v.(*ir.Const); isConst {
		if strings.HasSuffix(targetType, "*") && c.Value == 0 { return "null" }
		if strings.HasSuffix(targetType, "*") { return fmt.Sprintf("inttoptr (%s %s to %s)", currentType, valStr, targetType) }
	}

	if _, isGlobal := v.(*ir.Global); isGlobal { return fmt.Sprintf("bitcast (%s %s to %s)", currentType, valStr, targetType) }
	return valStr
}

func (b *llvmBackend) genAdd(instr *ir.Instruction) {
	resultName := b.formatValue(instr.Result)
	lhs, rhs := instr.Args[0], instr.Args[1]

	_, isLhsGlobal := lhs.(*ir.Global)
	_, isRhsGlobal := rhs.(*ir.Global)
	isLhsFunc := isLhsGlobal && (b.prog.FindFunc(lhs.String()) != nil || b.funcSigs[lhs.String()] != "")
	isRhsFunc := isRhsGlobal && (b.prog.FindFunc(rhs.String()) != nil || b.funcSigs[rhs.String()] != "")

	lhsType, rhsType := b.getType(lhs), b.getType(rhs)
	isLhsPtr := strings.HasSuffix(lhsType, "*") || (isLhsGlobal && !isLhsFunc)
	isRhsPtr := strings.HasSuffix(rhsType, "*") || (isRhsGlobal && !isRhsFunc)

	if (isLhsPtr && !isRhsPtr) || (!isLhsPtr && isRhsPtr) {
		var ptr ir.Value
		var ptrType string
		var offset ir.Value
		if isLhsPtr {
			ptr, ptrType, offset = lhs, lhsType, rhs
		} else {
			ptr, ptrType, offset = rhs, rhsType, lhs
		}

		if ptrType == "unknown" { ptrType = "i8*" }

		i8PtrVal := b.prepareArg(ptr, "i8*")
		offsetVal := b.prepareArg(offset, b.wordType)

		gepResultTemp := b.newBackendTemp()
		fmt.Fprintf(b.out, "%s = getelementptr i8, i8* %s, %s %s\n", gepResultTemp, i8PtrVal, b.wordType, offsetVal)
		b.tempTypes[gepResultTemp] = "i8*"

		if ptrType != "i8*" {
			fmt.Fprintf(b.out, "\t%s = bitcast i8* %s to %s\n", resultName, gepResultTemp, ptrType)
		} else {
			fmt.Fprintf(b.out, "\t%s = bitcast i8* %s to i8*\n", resultName, gepResultTemp)
		}
		b.tempTypes[resultName] = ptrType
		return
	}

	if isLhsPtr && isRhsPtr {
		lhsInt := b.prepareArg(lhs, b.wordType)
		rhsInt := b.prepareArg(rhs, b.wordType)
		resultInt := b.newBackendTemp()

		fmt.Fprintf(b.out, "%s = add %s %s, %s\n", resultInt, b.wordType, lhsInt, rhsInt)
		b.tempTypes[resultInt] = b.wordType

		fmt.Fprintf(b.out, "\t%s = inttoptr %s %s to %s\n", resultName, b.wordType, resultInt, lhsType)
		b.tempTypes[resultName] = lhsType
		return
	}

	resultType := b.formatType(instr.Typ)
	if strings.HasSuffix(resultType, "*") {
		lhsInt := b.prepareArg(lhs, b.wordType)
		rhsInt := b.prepareArg(rhs, b.wordType)
		resultInt := b.newBackendTemp()

		fmt.Fprintf(b.out, "%s = add %s %s, %s\n", resultInt, b.wordType, lhsInt, rhsInt)
		b.tempTypes[resultInt] = b.wordType

		fmt.Fprintf(b.out, "\t%s = inttoptr %s %s to %s\n", resultName, b.wordType, resultInt, resultType)
		b.tempTypes[resultName] = resultType
	} else {
		lhsVals := b.prepareArg(lhs, resultType)
		rhsVals := b.prepareArg(rhs, resultType)
		fmt.Fprintf(b.out, "%s = add %s %s, %s\n", resultName, resultType, lhsVals, rhsVals)
		b.tempTypes[resultName] = resultType
	}
}

func (b *llvmBackend) genCall(instr *ir.Instruction) {
	resultName := ""
	if instr.Result != nil { resultName = b.formatValue(instr.Result) }

	callee := instr.Args[0]
	calleeStr := b.formatValue(callee)
	retType := b.getFuncSig(callee.String())

	var argParts []string
	for i, arg := range instr.Args[1:] {
		targetType := b.wordType
		if instr.ArgTypes != nil && i < len(instr.ArgTypes) {
			targetType = b.formatType(instr.ArgTypes[i])
		} else if g, ok := arg.(*ir.Global); ok {
			if _, isString := b.prog.IsStringLabel(g.Name); isString { targetType = "i8*" }
		}
		valStr := b.prepareArg(arg, targetType)
		argParts = append(argParts, fmt.Sprintf("%s %s", targetType, valStr))
	}

	if _, isGlobal := callee.(*ir.Global); !isGlobal {
		funcPtrType := fmt.Sprintf("%s (...)*", retType)
		calleeStr = b.prepareArg(callee, funcPtrType)
	}

	callStr := fmt.Sprintf("call %s %s(%s)", retType, calleeStr, strings.Join(argParts, ", "))

	if resultName != "" && retType != "void" {
		fmt.Fprintf(b.out, "%s = %s\n", resultName, callStr)
		b.tempTypes[resultName] = retType
	} else {
		fmt.Fprintf(b.out, "%s\n", callStr)
	}
}

func (b *llvmBackend) prepareArg(v ir.Value, targetType string) string {
	valStr := b.formatValue(v)
	if g, ok := v.(*ir.Global); ok {
		isFunc := b.prog.FindFunc(g.Name) != nil || b.funcSigs[g.Name] != ""
		if isFunc {
			if strings.HasPrefix(targetType, "i") && !strings.HasSuffix(targetType, "*") {
				funcSig := b.getFuncSig(g.Name) + " (...)*"
				castTemp := b.newBackendTemp()
				fmt.Fprintf(b.out, "\t%s = ptrtoint %s @%s to %s\n", castTemp, funcSig, g.Name, targetType)
				b.tempTypes[castTemp] = targetType
				return castTemp
			}
			return "@" + g.Name
		}
	}

	if _, ok := v.(*ir.Const); ok { return valStr }
	if _, ok := v.(*ir.FloatConst); ok { return valStr }

	currentType := b.getType(v)
	if currentType == targetType || currentType == "unknown" { return valStr }

	castTemp := b.newBackendTemp()
	b.out.WriteString("\t")
	b.out.WriteString(b.formatCast(valStr, castTemp, currentType, targetType))
	b.out.WriteString("\n")
	b.tempTypes[castTemp] = targetType
	return castTemp
}

func (b *llvmBackend) formatCast(sourceName, targetName, sourceType, targetType string) string {
	isSourcePtr, isTargetPtr := strings.HasSuffix(sourceType, "*"), strings.HasSuffix(targetType, "*")
	isSourceInt, isTargetInt := strings.HasPrefix(sourceType, "i") && !isSourcePtr, strings.HasPrefix(targetType, "i") && !isTargetPtr
	isSourceFloat, isTargetFloat := sourceType == "float" || sourceType == "double", targetType == "float" || targetType == "double"

	var castOp string
	switch {
	case sourceType == "i1" && isTargetInt: castOp = "zext"
	case isSourceInt && targetType == "i1": return fmt.Sprintf("%s = icmp ne %s %s, 0", targetName, sourceType, sourceName)
	case isSourceInt && isTargetPtr: castOp = "inttoptr"
	case isSourcePtr && isTargetInt: castOp = "ptrtoint"
	case isSourcePtr && isTargetPtr: castOp = "bitcast"
	case isSourceInt && isTargetInt:
		sourceBits, _ := strconv.Atoi(strings.TrimPrefix(sourceType, "i"))
		targetBits, _ := strconv.Atoi(strings.TrimPrefix(targetType, "i"))
		castOp = "sext"
		if sourceBits > targetBits { castOp = "trunc" }
	case isSourceInt && isTargetFloat: castOp = "sitofp"
	case isSourceFloat && isTargetInt: castOp = "fptosi"
	case isSourceFloat && isTargetFloat:
		castOp = "fpext"
		if sourceType == "double" { castOp = "fptrunc" }
	default: castOp = "bitcast"
	}
	return fmt.Sprintf("%s = %s %s %s to %s", targetName, castOp, sourceType, sourceName, targetType)
}

func (b *llvmBackend) getType(v ir.Value) string {
	valStr := b.formatValue(v)
	if t, ok := b.tempTypes[valStr]; ok { return t }
	if _, ok := v.(*ir.Const); ok { return b.wordType }
	if fc, ok := v.(*ir.FloatConst); ok { return b.formatType(fc.Typ) }
	if g, ok := v.(*ir.Global); ok {
		if _, isString := b.prog.IsStringLabel(g.Name); isString { return "i8*" }
	}
	return "unknown"
}

func (b *llvmBackend) newBackendTemp() string {
	name := fmt.Sprintf("%%.b%d", b.prog.GetBackendTempCount())
	b.prog.IncBackendTempCount()
	return name
}

func (b *llvmBackend) formatValue(v ir.Value) string {
	if v == nil { return "void" }
	switch val := v.(type) {
	case *ir.Const: return fmt.Sprintf("%d", val.Value)
	case *ir.FloatConst:
		if val.Typ == ir.TypeS {
			float32Val := float32(val.Value)
			float64Val := float64(float32Val)
			return fmt.Sprintf("0x%016X", math.Float64bits(float64Val))
		} else {
			return fmt.Sprintf("0x%016X", math.Float64bits(val.Value))
		}
	case *ir.Global: return "@" + val.Name
	case *ir.Temporary:
		safeName := strings.NewReplacer(".", "_", "[", "_", "]", "_").Replace(val.Name)
		if val.ID == -1 { return "%" + safeName }
		if safeName != "" { return fmt.Sprintf("%%.%s_%d", safeName, val.ID) }
		return fmt.Sprintf("%%t%d", val.ID)
	case *ir.Label: return "%" + val.Name
	case *ir.CastValue: return b.formatValue(val.Value)
	default: return ""
	}
}

func (b *llvmBackend) formatType(t ir.Type) string {
	switch t {
	case ir.TypeB: return "i8"
	case ir.TypeH: return "i16"
	case ir.TypeW: return "i32"
	case ir.TypeL: return "i64"
	case ir.TypeS: return "float"
	case ir.TypeD: return "double"
	case ir.TypeNone: return "void"
	case ir.TypePtr: return "i8*"
	default: return b.wordType
	}
}

func (b *llvmBackend) formatOp(op ir.Op) (string, string) {
	switch op {
	case ir.OpAdd: return "add", ""
	case ir.OpSub: return "sub", ""
	case ir.OpMul: return "mul", ""
	case ir.OpDiv: return "sdiv", ""
	case ir.OpRem: return "srem", ""
	case ir.OpAddF: return "fadd", ""
	case ir.OpSubF: return "fsub", ""
	case ir.OpMulF: return "fmul", ""
	case ir.OpDivF: return "fdiv", ""
	case ir.OpRemF: return "frem", ""
	case ir.OpNegF: return "fneg", ""
	case ir.OpAnd: return "and", ""
	case ir.OpOr: return "or", ""
	case ir.OpXor: return "xor", ""
	case ir.OpShl: return "shl", ""
	case ir.OpShr: return "ashr", ""
	case ir.OpCEq: return "icmp", "eq"
	case ir.OpCNeq: return "icmp", "ne"
	case ir.OpCLt: return "icmp", "slt"
	case ir.OpCGt: return "icmp", "sgt"
	case ir.OpCLe: return "icmp", "sle"
	case ir.OpCGe: return "icmp", "sge"
	default: return "unknown_op", ""
	}
}

func (b *llvmBackend) escapeString(s string) string {
	var sb strings.Builder
	for _, byteVal := range []byte(s) {
		if byteVal < 32 || byteVal > 126 || byteVal == '"' || byteVal == '\\' {
			sb.WriteString(fmt.Sprintf("\\%02X", byteVal))
		} else {
			sb.WriteByte(byteVal)
		}
	}
	return sb.String()
}

func (b *llvmBackend) isPointerValue(v ir.Value) bool {
	if g, ok := v.(*ir.Global); ok {
		if _, isString := b.prog.IsStringLabel(g.Name); isString { return true }
		return b.prog.FindFunc(g.Name) == nil && b.funcSigs[g.Name] == ""
	}
	return false
}

func (b *llvmBackend) prepareArgForComparison(v ir.Value, targetType string) string {
	if c, isConst := v.(*ir.Const); isConst && c.Value == 0 && strings.HasSuffix(targetType, "*") { return "null" }
	return b.prepareArg(v, targetType)
}
