/*
 * textfmt.b - A simple text formatter.
 *
 * This program reads text from standard input, formats it to a fixed
 * line width, and prints it to standard output. It demonstrates a mix
 * of classic, untyped B for the main logic and new, typed Bx for
 * helper functions where type clarity is beneficial.
 *
 * Compile with: gbc textfmt.b -o textfmt
 * Run with: ./textfmt < input.txt
 */

extrn putchar, getchar;

/* --- Global Variables --- */

MAX_WIDTH 70; /* The maximum width of a line of text. */

byte line_buf[100]; /* Buffer to hold the current line. */
byte word_buf[50];  /* Buffer to hold the current word. */
int line_len;      /* Current length of the line in line_buf. */
int word_len;      /* Current length of the word in word_buf. */

/*
 * Bx: A typed helper function to print a string.
 */
void print_string(s byte*, len int) {
    auto i;
    i = 0;
    while (i < len) {
        putchar(s[i]);
        i++;
    }
}

/*
 * Bx: A typed helper function to flush the current line buffer.
 */
void flush_line() {
    if (line_len > 0) {
        print_string(line_buf, line_len);
        putchar('\n');
    }
    line_len = 0;
}

/*
 * Bx: A typed function to append a word to the current line.
 */
void append_word_to_line() {
    auto i;

    /* Add a space before the word if the line isn't empty. */
    if (line_len > 0) {
        line_buf[line_len] = ' ';
        line_len++;
    }

    i = 0;
    while (i < word_len) {
        line_buf[line_len] = word_buf[i];
        line_len++;
        i++;
    }
    word_len = 0; /* Reset word buffer after appending */
}

/*
 * main() - The main program logic.
 */
main() {
    auto c;

    line_len = 0;
    word_len = 0;

    while ((c = getchar()) != -1) { /* -1 is EOF */
        if (c == ' ' || c == '\t' || c == '\n') {
            /* Whitespace detected, process the completed word. */
            if (word_len > 0) {
                if (line_len + word_len + 1 > MAX_WIDTH) {
                    /* Word doesn't fit, flush the current line first. */
                    flush_line();
                }
                append_word_to_line();
            }

            if (c == '\n') {
                /* An explicit newline in the input flushes the current line. */
                flush_line();
            }
        } else {
            /* It's a character for the current word. */
            if (word_len < 49) {
                word_buf[word_len] = c;
                word_len++;
            }
        }
    }

    /* End of input, process any remaining word and flush the last line. */
    if (word_len > 0) {
        if (line_len + word_len + 1 > MAX_WIDTH) {
            flush_line();
        }
        append_word_to_line();
    }
    flush_line();

    return (0);
}
